<div id="qcard-{{ q.id }}" class="border rounded-2xl p-4 bg-white">
    <div class="flex items-start justify-between gap-3">
        <div>
            <div class="flex gap-2 items-start text-sm font-semibold">
                <span>{{ q.order }}.</span> 
                <div class="text-muted">
                    {{ q.prompt|safe }}
                </div>    
            </div>
            <div class="text-xs text-gray-500 mt-1">“∞–ø–∞–π: {{ q.points }}</div>
        </div>

        {% if saved %}
            <span class="text-xs px-2 py-1 rounded-full bg-green-50 border border-green-200 text-green-700">
                –°–∞“õ—Ç–∞–ª–¥—ã ‚úÖ
            </span>
        {% endif %}
    </div>

    <div class="mt-4">
        {% if q.question_type == "mcq_single" %}
            <form 
                hx-post="{% url 'customer:attempt_answer' attempt.id q.id %}" 
                hx-target="#qcard-{{ q.id }}"
                hx-swap="outerHTML"
            >
                {% csrf_token %}
                <div class="space-y-2">
                    {% for opt in q.options.all %}
                        <label
                            class="flex items-start gap-3 p-3 rounded-xl border cursor-pointer {% if opt.id in selected_set %} bg-secondary-50{% endif %}">
                            <input 
                                type="radio" 
                                name="option" 
                                value="{{ opt.id }}" 
                                {% if opt.id in selected_set %}checked{% endif %} 
                                class="mt-1"
                            >
                            <div class="text-sm">{{ opt.text|safe }}</div>
                        </label>
                    {% endfor %}
                </div>

                <button type="submit" class="mt-3 px-4 py-2 rounded-xl bg-gray-900 text-white text-sm font-medium">
                    –ñ–∞—É–∞–ø—Ç—ã —Å–∞“õ—Ç–∞—É
                </button>
            </form>

        {% elif q.question_type == "mcq_multi" %}
            <form hx-post="{% url 'customer:attempt_answer' attempt.id q.id %}" hx-target="#qcard-{{ q.id }}"
                hx-swap="outerHTML">
                {% csrf_token %}
                <div class="space-y-2">
                    {% for opt in q.options.all %}
                    <label
                        class="flex items-start gap-3 p-3 rounded-xl border cursor-pointer {% if opt.id in selected_set %} bg-gray-50{% endif %}">
                        <input 
                            type="checkbox" 
                            name="options" 
                            value="{{ opt.id }}" 
                            {% if opt.id in selected_set %}checked{% endif %} 
                            class="mt-1"
                        >
                        <div class="text-sm">{{ opt.text|safe }}</div>
                    </label>
                    {% endfor %}
                </div>

                <button type="submit" class="mt-3 px-4 py-2 rounded-xl bg-gray-900 text-white text-sm font-medium">
                    –ñ–∞—É–∞–ø—Ç—ã —Å–∞“õ—Ç–∞—É
                </button>
            </form>

        {% elif q.question_type == "speaking_keywords" %}
            <div class="mt-4 space-y-3">
            
                <div class="flex items-center gap-2">
                    <button type="button" class="px-4 py-2 bg-primary-600 text-white rounded-xl" data-rec-start="{{ q.id }}">
                        üéô –ñ–∞–∑—É–¥—ã –±–∞—Å—Ç–∞—É
                    </button>
                    <button type="button" class="px-4 py-2 bg-gray-200 rounded-xl hidden" data-rec-stop="{{ q.id }}">
                        ‚èπ –¢–æ“õ—Ç–∞—Ç—É
                    </button>
                    <span class="text-sm text-muted" data-rec-status="{{ q.id }}"></span>
                </div>
            
                <audio class="w-full hidden" controls data-rec-audio="{{ q.id }}"></audio>
            
                <div class="hidden" data-rec-upload="{{ q.id }}">
                    <button type="button" class="px-4 py-2 bg-primary-600 text-white rounded-xl" data-rec-send="{{ q.id }}"
                        data-upload-url="{% url 'customer:attempt_speaking_upload' attempt.id q.id %}" data-csrf="{{ csrf_token }}">
                        –ñ—ñ–±–µ—Ä—É
                    </button>
                    <button type="button"
                            class="px-4 py-2 bg-red-100 text-red-600 rounded-xl"
                            data-rec-clear="{{ q.id }}">
                        üóë ”®—à—ñ—Ä—É
                    </button>
                </div>
            </div>

            <script>
                (() => {
                    const state = new Map();

                    function qs(sel) { return document.querySelector(sel); }
                    function qsa(sel) { return Array.from(document.querySelectorAll(sel)); }

                    async function startRec(qid) {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        const rec = new MediaRecorder(stream, { mimeType: "audio/webm" });
                        const chunks = [];
                        rec.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };
                        rec.onstop = () => { stream.getTracks().forEach(t => t.stop()); };

                        state.set(qid, { recorder: rec, chunks, blob: null });

                        rec.start();

                        const status = qs(`[data-rec-status="${qid}"]`);
                        if (status) status.textContent = "–ñ–∞–∑—ã–ª—ã–ø –∂–∞—Ç—ã—Ä‚Ä¶";

                        const stopBtn = qs(`[data-rec-stop="${qid}"]`);
                        if (stopBtn) stopBtn.classList.remove("hidden");
                    }

                    function stopRec(qid) {
                        const s = state.get(qid);
                        if (!s || !s.recorder) return;

                        s.recorder.onstop = () => {
                            const blob = new Blob(s.chunks, { type: "audio/webm" });
                            s.blob = blob;

                            const audio = qs(`[data-rec-audio="${qid}"]`);
                            if (audio) {
                                audio.src = URL.createObjectURL(blob);
                                audio.classList.remove("hidden");
                            }

                            const uploadBox = qs(`[data-rec-upload="${qid}"]`);
                            if (uploadBox) uploadBox.classList.remove("hidden");

                            const status = qs(`[data-rec-status="${qid}"]`);
                            if (status) status.textContent = "–î–∞–π—ã–Ω. –ñ—ñ–±–µ—Ä—É–≥–µ –±–æ–ª–∞–¥—ã.";
                        };

                        s.recorder.stop();

                        const stopBtn = qs(`[data-rec-stop="${qid}"]`);
                        if (stopBtn) stopBtn.classList.add("hidden");
                    }

                    async function sendRec(qid, url, csrf) {
                        const s = state.get(qid);
                        if (!s || !s.blob) return;

                        const fd = new FormData();
                        fd.append("audio", s.blob, `speaking-${qid}.webm`);

                        const res = await fetch(url, {
                            method: "POST",
                            body: fd,
                            headers: { "X-CSRFToken": csrf, "HX-Request": "true" }
                        });

                        const html = await res.text();
                        const target = document.getElementById(`qcard-${qid}`);
                        if (target) target.outerHTML = html;
                    }

                    function clearRec(qid) {
                        const s = state.get(qid);
                        if (!s) return;

                        s.blob = null;
                        s.chunks = [];

                        const audio = qs(`[data-rec-audio="${qid}"]`);
                        if (audio) {
                            audio.src = "";
                            audio.classList.add("hidden");
                        }

                        const uploadBox = qs(`[data-rec-upload="${qid}"]`);
                        if (uploadBox) uploadBox.classList.add("hidden");

                        const status = qs(`[data-rec-status="${qid}"]`);
                        if (status) status.textContent = "–ñ–∞–∑–±–∞ ”©—à—ñ—Ä—ñ–ª–¥—ñ.";

                        state.delete(qid);
                    }

                    document.addEventListener("click", async (e) => {
                        const startBtn = e.target.closest("[data-rec-start]");
                        if (startBtn) {
                            const qid = startBtn.getAttribute("data-rec-start");
                            try { await startRec(qid); } catch (_) { }
                            return;
                        }

                        const stopBtn = e.target.closest("[data-rec-stop]");
                        if (stopBtn) {
                            const qid = stopBtn.getAttribute("data-rec-stop");
                            stopRec(qid);
                            return;
                        }

                        const sendBtn = e.target.closest("[data-rec-send]");
                        if (sendBtn) {
                            const qid = sendBtn.getAttribute("data-rec-send");
                            const url = sendBtn.getAttribute("data-upload-url");
                            const csrf = sendBtn.getAttribute("data-csrf");
                            await sendRec(qid, url, csrf);
                        }

                        const clearBtn = e.target.closest("[data-rec-clear]");
                        if (clearBtn) {
                            const qid = clearBtn.getAttribute("data-rec-clear");
                            clearRec(qid);
                            return;
                        }
                    });
                })();
            </script>
        {% endif %}

        {% if q.question_type == "speaking_keywords" and qa.is_answered %}
            <div class="mt-4 p-3 bg-secondary-50 rounded-xl">
                <div><strong>–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—è:</strong></div>
                <div class="mt-1 text-muted">
                    {{ qa.answer_json.transcript }}
                </div>

                <div class="mt-2">
                    <strong>–¢–∞–±—ã–ª“ì–∞–Ω –∫—ñ–ª—Ç—Ç—ñ–∫ —Å”©–∑–¥–µ—Ä:</strong>
                    {{ qa.answer_json.matched_keywords|join:", " }}
                </div>

                <div class="mt-2 font-semibold">
                    –ë–∞–ª–ª: {{ qa.score }} / {{ qa.max_score }}
                </div>
            </div>

        {% elif q.question_type == "writing" %}
            <div class="mt-4 space-y-3">
                <div>
                    <div class="text-sm font-medium mb-1">–ö–æ–¥ (—Ç—Ä–µ–Ω–∞–∂–µ—Ä)</div>
                    <div class="w-full" style="height:60vh;">
                        <iframe
                            src="https://www.onlineide.pro/playground/python"
                            class="w-full h-full block"
                            style="border:0;"
                        ></iframe>
                    </div>
                </div>

                <form id="wform-{{ q.id }}"
                    hx-post="{% url 'customer:attempt_writing_submit' attempt.id q.id %}"
                    hx-target="#qcard-{{ q.id }}"
                    hx-swap="outerHTML">
                {% csrf_token %}

                <div>
                    <div class="text-sm font-medium mb-1">–ù”ô—Ç–∏–∂–µ (output) –µ–Ω–≥—ñ–∑—ñ“£—ñ–∑</div>
                    <textarea 
                        name="output_text"
                        class="w-full min-h-27.5 font-mono text-sm border rounded-xl p-3"
                        required
                    >{% if writing_sub %}{{ writing_sub.output_text }}{% endif %}</textarea>
                </div>

                <button type="submit"
                        class="px-4 py-2 bg-primary-600 text-white rounded-xl">
                    –ñ—ñ–±–µ—Ä—É
                </button>
                </form>

                {% if qa and qa.is_graded %}
                <div class="p-3 rounded-xl text-sm {% if qa.score == qa.max_score %}bg-green-50{% else %}bg-red-50{% endif %}">
                    –ù”ô—Ç–∏–∂–µ: <strong>{{ qa.score }}</strong> / {{ qa.max_score }}
                </div>
                {% endif %}
            </div>

            <script>
                (function () {
                    function initEditors(root) {
                        const areas = (root || document).querySelectorAll('textarea[data-cm="1"]');
                        areas.forEach((ta) => {
                            if (ta._cm) return; // “õ–∞–π—Ç–∞ init –∂–∞—Å–∞–º–∞—É (HTMX swap –±–æ–ª“ì–∞–Ω–¥–∞ –∫–µ—Ä–µ–∫)

                            const cm = CodeMirror.fromTextArea(ta, {
                                lineNumbers: true,
                                mode: "python",      // “õ–∞–∂–µ—Ç –±–æ–ª–º–∞—Å–∞ –∞–ª—ã–ø —Ç–∞—Å—Ç–∞“£—ã–∑
                                indentUnit: 4,
                                tabSize: 4,
                                viewportMargin: Infinity,
                            });

                            // HTMX submit –∫–µ–∑—ñ–Ω–¥–µ textarea value –¥“±—Ä—ã—Å –∫–µ—Ç—É—ñ “Ø—à—ñ–Ω sync
                            cm.on("change", () => cm.save());

                            ta._cm = cm;
                        });
                    }

                    // –∞–ª“ì–∞—à“õ—ã –∂“Ø–∫—Ç–µ—É
                    initEditors(document);

                    // HTMX –∫–∞—Ä—Ç–æ—á–∫–∞ –∞—É—ã—Å“õ–∞–Ω–¥–∞ “õ–∞–π—Ç–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
                    document.body.addEventListener("htmx:afterSwap", function (e) {
                        initEditors(e.target);
                    });
                })();
            </script>
        {% endif %}
    </div>
</div>